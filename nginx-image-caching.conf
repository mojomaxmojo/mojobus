# Nginx Configuration for Optimized Image Caching
# MojoBus Blog - Intelligent Image Caching Strategy

server {
    listen 80;
    server_name mojobus.org www.mojobus.org;
    root /var/www/mojobus;
    index index.html;
    
    # Security headers
    add_header X-Frame-Options "DENY";
    add_header X-Content-Type-Options "nosniff";
    add_header X-XSS-Protection "1; mode=block";
    add_header Referrer-Policy "strict-origin-when-cross-origin";
    
    # Enable gzip compression
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/javascript
        application/xml+rss
        application/json
        image/svg+xml
        image/x-icon
        application/vnd.ms-fontobject;
        font/truetype
        font/opentype
        image/jpeg
        image/png
        image/gif
        image/webp;
        image/avif;
        image/svg+xml;
    
    # Set expires and cache control for static files
    expires 1y;
    add_header Cache-Control "public, immutable";
    
    # Root location
    location / {
        try_files $uri $uri/ /index.html =404;
        
        # Handle HTML files (shorter cache)
        location ~* \.(html|htm)$ {
            expires 24h;
            add_header Cache-Control "public, no-cache";
            add_header Pragma "no-cache";
            add_header "X-Content-Type-Options" "nosniff";
        }
    }
    
    # User uploaded images - 1 year cache (rarely changes)
    location /uploads/ {
        expires 1y;
        add_header Cache-Control "public, max-age=31536000, immutable";
        add_header X-Image-Cache-Strategy "UPLOADED-1YEAR";
        add_header X-Image-Cache-Reason "User uploaded content rarely changes";
        
        # Prevent hotlinking from other domains
        valid_referers none blocked;
        valid_referers server_names mojobus.org www.mojobus.org;
        
        # Image-specific optimization
        location ~* \.(jpg|jpeg|png|gif|webp|avif|svg)$ {
            add_header X-Content-Type-Options "nosniff";
            
            # Conditional request handling
            if_modified_since $sent_http_if_modified_since {
                add_header X-Cache-Status "HIT-304";
                return 304;
            }
            
            # ETag generation based on file content
            location ~* \.(jpg|jpeg|png|gif|webp|avif)$ {
                set $etag $upstream_http_last_modified;
            }
        }
    }
    
    # System branding images - 30 days cache
    location ~* ^/(mojobuslogo|bangkok)\.(png|jpg|jpeg|svg|webp|avif)$ {
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
        add_header X-Image-Cache-Strategy "SYSTEM-30DAYS";
        add_header X-Image-Cache-Reason "System branding images";
        add_header X-Content-Type-Options "nosniff";
        
        # Shorter cache for system updates
        if_modified_since $sent_http_if_modified_since {
            add_header X-Cache-Status "HIT-304";
            return 304;
        }
    }
    
    # Generated thumbnails - 7 days cache
    location /thumbnails/ {
        expires 7d;
        add_header Cache-Control "public, max-age=604800, immutable";
        add_header X-Image-Cache-Strategy "THUMBNAILS-7DAYS";
        add_header X-Image-Cache-Reason "Generated thumbnails may be updated";
        add_header X-Content-Type-Options "nosniff";
        
        # Very aggressive caching for thumbnails
        location ~* \.(jpg|jpeg|png|webp|avif)$ {
            add_header X-Cache-Aggressive "true";
        }
        
        if_modified_since $sent_http_if_modified_since {
            add_header X-Cache-Status "HIT-304";
            return 304;
        }
    }
    
    # User avatars - 1 day cache with revalidation
    location /avatars/ {
        expires 1d;
        add_header Cache-Control "public, max-age=86400, must-revalidate";
        add_header X-Image-Cache-Strategy "AVATARS-1DAY";
        add_header X-Image-Cache-Reason "User avatars may change";
        add_header X-Content-Type-Options "nosniff";
        
        # Stale-while-revalidate for avatars
        add_header "X-Stale-While-Revalidate" "86400";
        
        # Always revalidate avatars on first load
        proxy_cache_bypass $cookie_user_avatar_revalidate;
        set $cookie_user_avatar_revalidate 1;
    }
    
    # Temporary uploads - no cache
    location /temp/ {
        expires -1;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
        add_header Pragma "no-cache";
        add_header "X-Image-Cache-Strategy "TEMPORARY";
        add_header X-Image-Cache-Reason "Temporary upload cache bypass";
        add_header X-Content-Type-Options "nosniff";
        add_header Surrogate-Control "no-store";
        
        # Ensure no browser caching of temporary files
        add_header "X-Accel-Expires" "0";
        add_header "Pragma: no-cache";
        add_header "Cache-Control: post-check=0, pre-check=0";
    }
    
    # Fallback/system images - 30 days cache
    location /assets/images/ {
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
        add_header X-Image-Cache-Strategy "FALLBACK-30DAYS";
        add_header X-Image-Cache-Reason "Fallback/system images";
        add_header X-Content-Type-Options "nosniff";
        
        if_modified_since $sent_http_if_modified_since {
            add_header X-Cache-Status "HIT-304";
            return 304;
        }
    }
    
    # Auto-generated WebP images - very aggressive caching
    location ~* ^/auto/.*\.webp$ {
        expires 2y;
        add_header Cache-Control "public, max-age=63072000, immutable";
        add_header X-Image-Cache-Strategy "AUTO-WEBP-2Y";
        add_header X-Image-Cache-Reason "Auto-generated WebP images";
        add_header X-Content-Type-Options "nosniff";
        add_header Vary "Accept";
        
        # Serve WebP with proper content negotiation
        location ~* ^/auto/.*\.(jpg|jpeg|png)$ {
            add_header Vary "Accept, User-Agent";
            add_header X-Image-Original-Type "original";
            
            # Check if client supports WebP
            set $webp_supported 0;
            if ($http_accept ~*webp) {
                set $webp_supported 1;
            }
        }
    }
    
    # AVIF images - very aggressive caching (next-gen)
    location ~* ^/avif/.*\.avif$ {
        expires 2y;
        add_header Cache-Control "public, max-age=63072000, immutable";
        add_header X-Image-Cache-Strategy "AVIF-2Y";
        add_header X-Image-Cache-Reason "AVIF next-gen images";
        add_header X-Content-Type-Options "nosniff";
        add_header Vary "Accept, User-Agent";
        
        # Check if client supports AVIF
        set $avif_supported 0;
        if ($http_accept ~*avif) {
            set $avif_supported 1;
        }
    }
    
    # Progressive JPEG/PNG loading
    location ~* \.(jpg|jpeg)$ {
        # Enable progressive loading for JPEGs
        jpeg_quality 85;
        jpeg_progressive_mode 4;
        
        # Cache-control for progressive images
        expires 1y;
        add_header Cache-Control "public, max-age=31536000, immutable";
        add_header X-Image-Cache-Strategy "PROGRESSIVE-JPEG";
        add_header X-Content-Type-Options "nosniff";
        
        if_modified_since $sent_http_if_modified_since {
            add_header X-Cache-Status "HIT-304";
            return 304;
        }
    }
    
    location ~* \.png$ {
        # Optimize PNG compression
        gzip_static on;
        gzip_http_version 1.1;
        gzip_comp_level 9;
        gzip_vary on;
        
        expires 1y;
        add_header Cache-Control "public, max-age=31536000, immutable";
        add_header X-Image-Cache-Strategy "OPTIMIZED-PNG";
        add_header X-Content-Type-Options "nosniff";
        
        if_modified_since $sent_http_if_modified_since {
            add_header X-Cache-Status "HIT-304";
            return 304;
        }
    }
    
    # Content delivery and range request support
    location ~* \.(jpg|jpeg|png|gif|webp|avif|svg)$ {
        add_header Accept-Ranges "bytes";
        
        # Security headers for images
        add_header "X-Content-Type-Options" "nosniff";
        
        # CORS for web applications
        add_header "Access-Control-Allow-Origin" "$http_origin";
        add_header "Access-Control-Allow-Methods" "GET, HEAD, OPTIONS";
        add_header "Access-Control-Allow-Headers" "Range, Content-Type, If-Modified-Since, If-None-Match";
        
        # Add image metadata headers
        add_header X-Image-Served-By "nginx-mojobus-v1";
        add_header X-Image-Cache-Timestamp "$msec";
        add_header X-Image-File-Size "$content_length";
    }
    
    # Rate limiting for image requests
    location ~* \.(jpg|jpeg|png|gif|webp|avif)$ {
        limit_req zone=$binary_remote_addr burst=10 nodelay=1;
        limit_req_zone=$binary_remote_addr burst=50 nodelay=10;
        
        # Different limits for different strategies
        if ($request_uri ~* "/temp/") {
            limit_req zone=$binary_remote_addr burst=5 nodelay=1;
        }
        
        # Cache-Status for rate limiting
        add_header X-Image-RateLimit "Burst-50-Nodelay-10";
        
        # Only log rate-limited requests
        limit_req_status 429;
        access_log /var/log/nginx/ratelimited_images.log;
    }
    
    # Fallback when image not found
    error_page 404 /assets/images/fallback/not-found.jpg;
    
    # Fallback for server errors
    error_page 500 502 503 504 /assets/images/fallback/server-error.jpg;
    
    # Maintenance page
    error_page 503 /maintenance.html;
}

# Image-specific log format
log_format image '$remote_addr - $remote_user [$time_local] "$request" $status '
           'bytes=$body_bytes_sent '
           '"$http_referer" '
           '"$http_user_agent" '
           'cache=$sent_http_x_image_cache_strategy '
           'etag=$sent_http_etag" '
           'req_time=$request_time';

# Access log for image requests
access_log /var/log/nginx/image_access.log image buffer=32k flush=5m;

# Slow image request logging
log_format slow_image '$remote_addr - $remote_user [$time_local] "$request" $status '
                 'bytes=$body_bytes_sent '
                 'request_time=$request_time '
                 'upstream_response_time=$upstream_response_time '
                 'upstream_addr=$upstream_addr '
                 'upstream_cache_status=$upstream_cache_status '
                 'rt=$request_time $upstream_response_time';

# Log slow image requests (> 1 second)
map $request_time $upstream_response_time $slow_request_time {
    default 0;
    ~\d+0\.(\d{2})\d+ $slow_request_time = $slow_request_time;
}
access_log /var/log/nginx/slow_images.log slow_image buffer=32k flush=5m;

# Worker processes for image processing
worker_processes auto;
worker_connections 1024;

# Image-specific buffer settings
client_body_buffer_size 128k;
client_max_body_size 10m;
client_header_buffer_size 4k;
large_client_header_buffers 4 8k;
client_body_timeout 60s;

# TCP optimization
tcp_nopush on;
tcp_nodelay on;
keepalive_timeout 65s;
keepalive_requests 100;

# Sendfile optimization for large images
sendfile on;
sendfile_max_chunk_size 512k;
tcp_nopush on;
directio 2M;